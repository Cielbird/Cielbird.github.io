<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://cielbird.github.io name=base><title>
            
                Censoring clowns with FPGA
            
        </title><meta content="Censoring clowns with FPGA" property=og:title><link href=https://cielbird.github.io/fonts.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=/syntax-theme-dark.css rel=stylesheet><link media="(prefers-color-scheme: light)" href=/syntax-theme-light.css rel=stylesheet><script defer src=https://cielbird.github.io/js/codeblock.js></script><script defer src=https://cielbird.github.io/js/toc.js></script><script defer src=https://cielbird.github.io/js/note.js></script><script>MathJax = {
                    tex: {
                        inlineMath: [
                            ['$', '$'],
                            ['\\(', '\\)']
                        ]
                    }
                };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="
    cielbird
" href=https://cielbird.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://cielbird.github.io/theme/light.css rel=stylesheet><link href=https://cielbird.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://cielbird.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://cielbird.github.io/main.css media=screen rel=stylesheet><script src="https://cielbird.github.io/search_index.en.js?h=4a07d0cfaf17a5a49bae" defer></script><script src="https://cielbird.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=left-content></div><div class=content><nav><div class=left-nav><a class=logo href=https://cielbird.github.io> <img alt=cielbird src=https://cielbird.github.io/logo.jpg> </a><div class=socials><a rel="'me'" class=social href=https://www.linkedin.com/in/guilhemane/> <img alt=linkedin src=https://cielbird.github.io/icons/social/linkedin.svg> </a><a rel="'me'" class=social href=https://github.com/cielbird/> <img alt=github src=https://cielbird.github.io/icons/social/github.svg> </a><a rel="'me'" class=social href=mailto:guilhem.ane3@gmail.com> <img alt=email src=https://cielbird.github.io/icons/social/email.svg> </a></div></div><div class=right-nav><a href=https://cielbird.github.io/blog style=margin-right:.5em>/blog</a><a href=https://cielbird.github.io/projects style=margin-right:.5em>/projects</a><a href=https://cielbird.github.io/about style=margin-right:.5em>/about</a><a href=https://cielbird.github.io/tags style=margin-right:.5em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://cielbird.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://cielbird.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://cielbird.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Censoring clowns with FPGA</div><div class=meta>Posted on <time>2024-12-03</time> :: Updated on <time>2025-10-30</time><span class=tags-label>::</span><span class=tags> <a class=post-tag href=https://cielbird.github.io/tags/fpga/>fpga</a> <a class=post-tag href=https://cielbird.github.io/tags/ai/>ai</a> </span></div></div><section class=body><p>In this blog post, I'll talk about an interesting project I worked on, and what I would have done differently.<p>I was working on a demonstration project about face detection and censoring. Instead of designing a CNN/YOLO model on FPGA (which would have been a crazy project on its own), we used simple color detection. The trick: the user would wear a red clown nose, which would be reliable to detect. It was a sort of 'clown censorship device', funny and perfectly acceptable for the context.<p>At first, we used a 256x256 black rectangle to mask the area detected by our red color detection.<p>It was my job to implement a blur in the detection zone. This requires a convolutional filter, with a blurring kernel.</p><img aspect-ratio="847 / 847" alt=Demo decoding=async loading=lazy src=https://cielbird.github.io/processed_images/demo.9a2d8bfddc61fd39.avif><p><em>This is what the clown censoring looked like. I had it configured to track a blue color,</em> <em>so I was holding up a blue paper on my nose. It was very fun to play with!</em><h1 id=game-plan><a aria-label="Anchor link for: game-plan" class=zola-anchor href=#game-plan>Game plan</a></h1><p>HDMI sweeps the image on the screen in rows: left to right, and top to bottom. So when displaying a pixel, I don't know what color the pixel to the right will be. So to apply a filter on an image, I needed to use some previous frame as input. This meant I needed to store the entire region in memory.<p>My first game plan was as follows:<ul><li>In one frame, store the face's image.<li>On the next frame, display the previous frame's filtered image in the new detection zone.</ul><h2 id=downsampling><a aria-label="Anchor link for: downsampling" class=zola-anchor href=#downsampling>Downsampling</a></h2><p>The first issue I ran into was storing the detected zone in registers. I had access to the pixel colors in RGB888 format, which is 3 bytes per pixel. So I needed $256 \times 256 \times 24 = 1572864$ flip-flops. That was way too much for the simple Zybo Z7-20 FPGA dev-board I was using.<p>I decided to downsample the input by a factor of 16; from 256x256 to 16x16. This inherently added some pixelization to the filter, which was fine.<p>For this crude application, I didn't do any anti-aliasing before downsampling.<p>I used a 3x3 kernel to apply the filter:<p>$$ O(x, y) = \sum_{i=-1}^{1} \sum_{j=-1}^{1} I(x+i, y+j) \times K(i, j) $$<p>The beautiful thing about FPGA is that all these operations can easily be in parallel.<h2 id=timing><a aria-label="Anchor link for: timing" class=zola-anchor href=#timing>Timing</a></h2><p>The second issue was timing. The convolution calculations are hefty, and I needed this done in only a couple clock cycles. This caused timing issues, and I struggled with the screen going black. This is what my code somewhat looked like at this stage:<pre class="language-vhdl z-code" data-lang=vhdl><code class=language-vhdl data-lang=vhdl><span class="z-text z-plain">architecture behavioral of conv3x3 is
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    -- 3x3 kernel as float constants
</span><span class="z-text z-plain">    constant K00 : float32 := to_float(1.0/16.0, float32'high);
</span><span class="z-text z-plain">    constant K01 : float32 := to_float(2.0/16.0, float32'high);
</span><span class="z-text z-plain">    constant K02 : float32 := to_float(1.0/16.0, float32'high);
</span><span class="z-text z-plain">    constant K10 : float32 := to_float(2.0/16.0, float32'high);
</span><span class="z-text z-plain">    constant K11 : float32 := to_float(4.0/16.0, float32'high);
</span><span class="z-text z-plain">    constant K12 : float32 := to_float(2.0/16.0, float32'high);
</span><span class="z-text z-plain">    constant K20 : float32 := to_float(1.0/16.0, float32'high);
</span><span class="z-text z-plain">    constant K21 : float32 := to_float(2.0/16.0, float32'high);
</span><span class="z-text z-plain">    constant K22 : float32 := to_float(1.0/16.0, float32'high);
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    signal sum : float32;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">begin
</span><span class="z-text z-plain">    process(all)
</span><span class="z-text z-plain">    begin
</span><span class="z-text z-plain">        sum := (p00*K00) + (p01*K01) + (p02*K02) +
</span><span class="z-text z-plain">               (p10*K10) + (p11*K11) + (p12*K12) +
</span><span class="z-text z-plain">               (p20*K20) + (p21*K21) + (p22*K22);
</span><span class="z-text z-plain">        result_out &lt;= sum;
</span><span class="z-text z-plain">    end process;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">end architecture;
</span></code></pre><p>There were two issues here:<ul><li>I wasn't pipelining my operations<li>I was using floating point arithmetic</ul><p>I added a 5 stage pipeline that helped divide the operations into smaller more manageable chunks. Now I could assure the whole calculation would only take 5 clock cycles.<pre class="language-vhdl z-code" data-lang=vhdl><code class=language-vhdl data-lang=vhdl><span class="z-text z-plain">type FSM_STATE is (IDLE, MULT, ADD_1, ADD_2, ADD_3, OUTPUT);
</span></code></pre><img alt="5 stage pipeline" aspect-ratio="773 / 773" decoding=async loading=lazy src=https://cielbird.github.io/processed_images/pipeline.d504a0ce2ca8eb24.avif><p>Second, I used integers instead of floats in the calculations. Using integers, I could simply multiply by 1, 2, and 4, and on the output step simply divide by 16 using a right-bit-shift. Using integers allowed me to go much faster, and I saw a noticeable drop in the instability of the design.<p>In the end, we had an architecture that looked something like this:</p><img aspect-ratio="2500 / 2500" alt=Architecture decoding=async loading=lazy src=https://cielbird.github.io/processed_images/full_diagram.e5e8ffe16cbadb2b.avif><p>Ultimately, this was a very fun project. Convolutions are everywhere, and opitimizing the calculation for a real-world application is pretty cool. The biggest mistake I made was ignoring BRAM. If I had used BRAM to store the input image, I could have avoided downsampling and taken advantage of the >600 KB of available memory on the Zybo Z7-20 FPGA dev-board.</section></article></main></div><div class=giscus></div><script async crossorigin issue-term=pathname repo=YOUR_NAME/YOUR_REPO src=https://utteranc.es/client.js theme=github-light></script></div><div class=right-content><div class=toc><div class=heading>Table of Contents</div><ul class=toc-list><li class=parent><a href=https://cielbird.github.io/blog/blurring-clowns/#game-plan>Game plan</a> <ul><li><a href=https://cielbird.github.io/blog/blurring-clowns/#downsampling>Downsampling</a><li><a href=https://cielbird.github.io/blog/blurring-clowns/#timing>Timing</a></ul></ul></div></div>